# Quest
_Список вопросов для самоподготовки к собеседованиям_
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
## Основы Kotlin 
 Какие основные отличия Kotlin от Java? Преимущества Kotlin
 > NullSafety, сокращение кодовой базы на 20%, companion object, data-class

**В чём заключается разница в Exeption в Kotlin и Java**
> Java - checked и unchecked, где checked - обязательно для обработки - иначе программа не скомпилирется\
> В Kotlin все исключения являются uncheked - т.е необязательные для обработки, программа скомпилируется в любом случае.\
> Однако, если разработчик решит не обрабатывать исключения, это может приводить к нежелательным последствиям (краши, ошибки)\

**Отличие при проверке на равенсто, "==", "===" и equals()**
 _Java_\
> Примитивы - при == сранивают значения и ссылки.\
> Объекты - при === сравнивает значения, при ==  только ссылки.\
> Новый объект - новая ссылка, даже если значения индетичны.\
_Kotlin_\
> Примитивы - == и === сравнивает данные,\
> Объекты - при == сравнивают данные, при === сравнивает ссылки.\
> Equals() - индентичен "==" (но есть нюансы с Double и Float) и для примитивов и для объектов.\

**Модификаторы доступа**
> Private - видимость только в пределах самого класса\
> Protected - видимость в пределах класса и наследников\
> Internal - видимость в пределах одного модуля\
> Public - видимость в пределах всего приложения

**Что такое null safety в Kotlin и как это работает?**
> Возможность избежать краша приложения из-за NPE\

_Как это работает_
> По умолчанию все типы в Kotlin - не нуллабельны\
> При инициализации переменной мы можем объявить ее как null_ельную, т.е возможно содержащую Null\
> Для этого используетя символ "?"\
```
val example:String? = null
> строка null? но это не вызовет ошбибку компилятора
```
_Почему это удобно?_
> Может быыть такая ситуация, что мы не знаем, будет ли переменная содержать значения или нет (например сервер возвращает объект где некоторые поля заполнены, а некоторые нет)\
> С помощью null safety мы можем избежать краша Npe при обработке ответа\
```
val newUser = user?.let {it.user}
> Если user не Null, мы запишем данные, в противном случае не будем делать ничего
```
```
val newUser = it.user?:"Васька"
> В данном случае если ответ будет не null - мы запишем данные из it.user, в противном случае в переменную упадет значение "Васька"
```
_Что делать если очень хочется Npe?_
> Использовать "!!" - таким образом, мы говорим компилятору: "Тут точно не null, отвечаю". Однако краши из-за Npe - теперь ответсвенность разработчика\

**Как объявить переменную в Kotlin? В чем разница между val и var?**
> С помощью ключевых слов val и var.  Неизменяемая и изменяемая переменная.\
> у Val есть только геттер, у var - геттер и сеттер
> Val значение которое можно назначить во время работы программы, const val - во время компиляциии программы\

**Объясните, что такое data class в Kotlin.**
> Удобный класс, в основном использую для хранения данных. В таком классе переопределены методы - ToString(), Equals(), HashCode(), Component().\
> Почему это удобно? Упрощние сравнение объектов и их сериализация, автоматически сгненнерированы сеттеры и геттеры для каждого поля\
> Метод copy() - который позволяет создать новый объект, интетичный предыдущему, но с изменнеными значениями некоторых полей по желанию\
_Какие существуют ограничения для таких кслассов?_
> Классы данных не могут быть abstract, open, sealed или inner.\
> Должно быть хоть одно поле в конструкторе - var или val\
_Можно ли наследоваться от таких классов?_\
> Нет, они по умолчанию final, но может наследоваться сам\

Как объявить функцию в Kotlin? 
> Ключевое слово fun

**Что такое companion object?**
> Анонимный класс, объявленный внутри класса, в некоторым роде аналог статическиз полей из Java\
>  Kotlin создает статическое поле внутри класса, которое хранит экземпляр анонимного объекта\
```
Когда использовать?
Для констант (например, const val TAG = "MyClass").
Для фабричных методов (например, create()).
Для реализации паттернов (Singleton, Factory и др.).
Для доступа к приватным членам класса извне.
```

**Что такое sealed class и когда их использовать?**
> Усовершенствованные enum, класс в который можно положить и другие class и объекты, имеет ограниченное наследование\
> У sealed класса могут быть наследники, но все они должны находиться в одном пакете с этим классом. Изолированный класс "открыт" для наследования по умолчанию, указывать слово open не требуется.\
> Наследники могут быть любого типа: data class, объектом, обычным классом, другим sealed классом. Классы, которые расширяют наследников sealed класса могут находиться где угодно.\
> Изолированные классы абстрактны и могут содержать в себе абстрактные компоненты.\
> Не могут быть inner.\

_Какие отличия между enum и seaed-class?_
> enum представляет собой конечный список значений, которые объявляются заранее в момент компиляции, и не могут быть расширены или изменены во время выполнения программы
> sealed class позволяет определять ограниченный набор значений, но эти значения могут быть расширены в будущем

**Как работает when в Kotlin?**
> Это аналог switch-case из java
```
Главные отличия от switch-case
Поддерживает любые условия, а не только константы.
Может работать без аргумента (аналог if-else if).
Может возвращать значение.
```
**Как создать singleton в Kotlin?**
> С помощью ключевого слово object\
> плюсы:\
> - Ленивая инициализация при первом обращении\
> - Потокобезопасность\
_Что если нужен синглтон с параметрами?_\
> У object нет конструктора, для синглтона с параметрами, можно использовать class+lazy\
```
class Singleton private constructor(val config: String) {
    companion object {
        val instance: Singleton by lazy { Singleton("default") }
    }
}
```
> или
```
class Singleton private constructor(val config: String) {
    companion object {
        @Volatile private var instance: Singleton? = null
        private val lock = Any()

        fun getInstance(config: String): Singleton {
            return instance ?: synchronized(lock) {
                instance ?: Singleton(config).also { instance = it }
            }
        }
    }

    fun doSomething() {
        println("Config: $config")
    }
}

// Использование
fun main() {
    val singleton = Singleton.getInstance("test")
    singleton.doSomething()  // Config: test
}
```
**Что такое Unit в Kotlin?**
> Аналог Void, то что возвращается из функции, в которой не указан возвращаемый тип.\
> Unit может использоваться с дженериками\

**Как работает lateinit и lazy?** 
> Оба ленивая инициализация
_lateinit_
> var, и обязуемся проинициализировать до первого обращения\
> если не проинициализируем - упадем\
_lazy_
> val и инициализируется автоматически при первом обращении
> не упадем, потому что инициализируем при первом обращеннии

**Как работает smart cast в Kotlin?**
> Умное приведение типов через специальное выражение is\
> Компилятор запоминает тип, и обращается к нему в области видисоости как к определенному\
```
if (cast is String){
тут переменная каст, будет считаться как String
 cast.lenght()
}
```
> as - явное приведение, при ошибке приведению типов бросит исключение

**Что такое интерфейсы и абстрактные классы? В чем их разница?**
>Оба понятия используются для абстракции (описания поведения без реализации), но имеют ключевые различия.\
>Абстрактные класс - класс, который нельзя создать напрямую (только через наследование). Может содержать:\
>абстрактные методы (без реализации, abstract fun),\
>обычные методы (с реализацией),\
>поля (свойства).\
>Использовать когда несколько классов должны иметь общую базовую логику.
>Интерфейс - контракт методов


-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
## Дженерики\Лямбды\Хай-левел и экстеншн функции

**Как использовать функции расширения в Kotlin?**
```
 fun Fragment.toast(@StringRes stringRes: Int) {
    Toast.makeText(requireContext(), stringRes, Toast.LENGTH_SHORT).show()}
```
>  теперь во фрагменте можно вызвать тост, только словом toast

**Что такое inline,reified, noinline и crossinline?*
> Это модификаторы для работы с лямбда - выражениями

_inline_
> Встроенная функция - встаивает код лямбды прямо вместо вызова функции - таким образом увеличивая оптимизацию

_noinline_
> Запрещает встраивание конкретной лямбды в inline-функции.Зачем: Если лямбда передаётся в другую не-inline функцию.Если нужно сохранить лямбду как объект (например, для отложенного выполнения).

_crossinline_
> Запрещает return в лямбде (локальный)

_reified_
> Делает generics конкретными. Позволяет использовать тип T как реальный (а не стираемый) внутри inline-функции.


**В чем разница между let, apply, also, run, with?**

_let_
> Для безопасной работы с nullable-объектами.\
> ("Пусть сделают с объетом что-то")\
> Выполнить операции над объектом и вернуть результат лямбды.\
```
val example = uri?.let{it.uri}
> "Eсли uri не пустой, пусть example присваивается it.uri"
```
_apply_
> Для инициализации или конфигурации объекта.\
>("Настрой объект так и верни")\
> Настроить объект (изменить его свойства) и вернуть сам объект (this).\
```
val result = object.apply { this -> ... }
```
_also_
> Для отладки или логгирования или когда нужно выполнить действие, но сохранить объект без изменений.
> ("Также сделай с объектом вот это и верни, но не сохраняй")
```
val list = mutableListOf(1, 2, 3).also {
    println("List before add: $it")  // Побочный эффект
    it.add(4)
}
```
_run_
> Работает как комбинация let + with: выполняет блок кода и возвращает результат лямбды.
> ??????

_with_
> ("Работай в контексте вот этого-вот")

**Что такое higher-order функции?**
> Higher-order functions (функции высшего порядка) — это функции, которые работают с другими функциями принимая их как аргументы или возвращая их как результат 

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
##Flow
**Какие виды flow существуют**
> Горячие и холодные flow
Холодные флоу (flow )- не будут работать если не подписаться (collect), как только отдадут все занчения - закончат выполнение, новая подписка - новый поток, нет подписчиков - нет потока
Горячие флоу (stateFlow) - работают независимо от наличия подписчиков, продолжают работу незавичимо есть данные или нет, никогда не завершается

**Что такое Flow и как он отличается от LiveData?**
> Flow - ассинхронный поток данных



-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
## Android SDK
**Расскажи что происходит при запуске приложения**
>1. Запуск процесса
```
Когда пользователь запускает приложение, операционная система Android создает новый процесс (если он еще не существует) и выделяет для него ресурсы.
Каждое приложение в Android работает в изолированном процессе с собственной виртуальной машиной (ART/Dalvik).
```
>2. Загрузка приложения
```
Система загружает код приложения из APK-файла.
Загружаются ресурсы приложения (изображения, строки, макеты и т.д.).
```
>3. Создание объекта Application
```
Если в приложении есть пользовательский класс, унаследованный от Application, система создает его экземпляр.
В этом классе можно выполнить инициализацию глобальных переменных или библиотек (например, Firebase, аналитика и т.д.).
```
>4. Запуск стартовой Activity
```
Система определяет, какая Activity должна быть запущена первой (указана в манифесте в теге <intent-filter> с действием MAIN и категорией LAUNCHER).
Создается экземпляр этой Activity.
```
> 5. Жизненный цикл Activity
```
OnCreate() - onStart() - OnResume()
```
> 6.  Отображение интерфейса\Работа приложения\Фоновые процессы
> 7.  Заверншение работы
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
## View\Ui
**ЖЦ View**
> Created (Создание): View создается программно или загружается из XML-макета. На этом этапе еще не произошло его отображение на экране.\
> Attached (Присоединение): View присоединяется к родительскому контейнеру (например, к Layout). На этом этапе начинают применяться параметры размещения и размеры.\
> Measured (Измерение): Система измеряет размеры и расположение View в контейнере, чтобы правильно разместить его на экране. Этот этап определяет размеры View и его дочерних элементов.\
> Layout (Размещение): View размещается внутри родительского контейнера с учетом измерений, определенных на предыдущем этапе.\
> Draw (Отрисовка): View отрисовывается на экране. На этом этапе происходит фактическое отображение элемента на экране, используя его графические ресурсы и атрибуты.\
> Detached (Отсоединение): View отсоединяется от родительского контейнера. Это может произойти при удалении View из иерархии или при временном скрытии.\
> Destroyed (Уничтожение): View уничтожается, освобождая память и ресурсы, занимаемые этим элементом. Этот этап может наступить при завершении работы Activity или в случае явного удаления View.\

**Как создать Custom View в Android?**
> Наследуем класс от View
```
class MyCustomView @JvmOverloads constructor(
    context: Context,
    attrs: AttributeSet? = null,
    defStyleAttr: Int = 0
) : View(context, attrs, defStyleAttr) { ...}
```
> В init обрабатываем кастомные атрибуту
```
    init {
        // Обработка кастомных атрибутов
        attrs?.let {
            val typedArray = context.obtainStyledAttributes(
                it,
                R.styleable.MyCustomView,
                defStyleAttr,
                0
            )

            customColor = typedArray.getColor(
                R.styleable.MyCustomView_customColor,
                Color.RED
            )
            customText = typedArray.getString(
                R.styleable.MyCustomView_customText
            ) ?: "Default"

            typedArray.recycle()
        }
    }
```
> Кастомные атрибуты можно установит через xml
```
<resources>
    <declare-styleable name="MyCustomView">
        <attr name="customColor" format="color"/>
        <attr name="customText" format="string"/>
        <attr name="customTextSize" format="dimension"/>
    </declare-styleable>
</resources>
```
> Переопределяем необходимые методы
```
override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {
    val minWidth = suggestedMinimumWidth + paddingLeft + paddingRight
    val minHeight = suggestedMinimumHeight + paddingTop + paddingBottom
    
    val width = resolveSize(minWidth, widthMeasureSpec)
    val height = resolveSize(minHeight, heightMeasureSpec)
    
    setMeasuredDimension(width, height)
}

override fun onDraw(canvas: Canvas) {
    super.onDraw(canvas)
    
    // Рисуем фон
    canvas.drawColor(customColor)
    
    // Рисуем текст по центру
    val textWidth = textPaint.measureText(customText)
    val x = (width - textWidth) / 2
    val y = (height - textPaint.textSize) / 2 + textPaint.textSize
    
    canvas.drawText(customText, x, y, textPaint)
}
```
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
## Compose
**Что такое remember и mutableStateOf в Compose?**
> mutableStateOf - это функция, которая создает наблюдаемое состояние и при изменении значения автоматически вызывает рекомпозицию всех зависимых от него композаблов\
> remember - это функция, которая сохраняет значение между рекомпозициями. Без remember значение будет сбрасываться при каждой рекомпозиции

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
## Dagger\Di

**Отличие @Provides от @Bind**
> Bind - Используется для связывания интерфейса/абстрактного класса с его реализацией\
> Например
```
@Module
abstract class StorageModule {
    @Binds
    abstract fun bindStorage(impl: SharedPrefStorage): Storage  // Storage — интерфейс
}
```
> Provide - Используется в модулях (@Module) для создания экземпляров зависимостей\
> Например:
```
@Module
class NetworkModule {
    @Provides
    fun provideOkHttpClient(): OkHttpClient {
        return OkHttpClient.Builder()
            .connectTimeout(30, TimeUnit.SECONDS)
            .build()
    }
}
> Создали экхемпляр класса okkhttp\
> Метод с @Provides выполняет код и возвращает готовый объект.
```
_Ключевые отличия_\
|Характеристика	    | @Provides	                                      || @Binds\
|Тип модуля         |	Обычный класс (class)                           ||	Абстрактный класс/интерфейс (abstract class/interface)\
|Логика создания    |	Содержит код (например, return OkHttpClient())	 || Только объявление (например, bindStorage(impl: SharedPrefStorage): Storage)\
|Использование      |	Для любых зависимостей                          ||	Только для интерфейсов/абстрактных классов\
|Производительность |	Медленнее (вызов метода)                        ||	Быстрее (нет вызова метода)\
|Гибкость	          | Можно добавить любую логику                     ||	Только связь интерфейса с реализацией\

**Как реализовать глубокие ссылки (Deep Links) в Android?**
> Глубокие ссылки (Deep Links) позволяют открывать определенные экраны или контент в приложении из внешних источников (веб).\
> Подключаем manifest -  добавляем intent-фильтры\
> Обрабатываем в коде

**Что такое MVP, MVVM, MVC, MVI и в чем их различия?**
> Это архитекутрные паттерны, для помощи организации кода в приложении\
> MVC - Model-View-Controller (Модель (бизнес-логика) - View (UI) - Коннтроллер(обрабатывает пользовательский ввод, управляет Model и обновляет View.) Проблемы:если логика накапливается в Controller, его сложно поддерживать.\
```
Как работает
Пользователь взаимодействует с View (например, нажимает кнопку).
View передает действие в Controller.
Controller обновляет Model.
Model уведомляет View об изменениях (через Observer или прямое обновление).
```
> MVP - Model-View-Presenter (старая система)
```
Как работает
Пользователь взаимодействует с View.
View делегирует действие Presenter.
Presenter обновляет Model.
Model возвращает данные Presenter.
Presenter обновляет View.
```
> MVVM -Model-ViewModel-Model
```
Как работает
Пользователь взаимодействует с View.
View делегирует действие ViewModel (через команды или привязки).
ViewModel обновляет Model.
Model может уведомить ViewModel (если используется Observer).
ViewModel автоматически обновляет View через data binding (например, в WPF, Android Jetpack, SwiftUI).
```
> MVI - Model - View - Intet
```
Как работает MVI?\
Пользователь совершает действие → View отправляет Intent.
Система обрабатывает Intent (например, делает API-запрос).
Результат преобразуется в новое состояние (Model).
View автоматически обновляется на основе нового состояния.
```

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
## Многопоточность
**Что такое процесс? Что такое поток?**
> Процесс — это программа в памяти со своей изолированной средой. Процессы используются реже (например, для запуска внешних утилит через ProcessBuilder).\
> Поток — это "легкий" процесс, выполняющийся внутри процесса и делящий его ресурсы. В Java/Kotlin обычно работают с потоками (Thread, корутины, ExecutorService).\
> Олин процесс, много потоков

**Как работает Atomic в Kotlin?**
> Atomic-классы предоставляют потокобезопасные операции над переменными без использования блокировок (synchronized). Они основаны на атомарных инструкциях процессора (CAS — Compare-And-Swap).
```
Atomic — это потокобезопасные классы для операций над числами и ссылками.
Работают через CAS (Compare-And-Swap), без блокировок.
Лучше synchronized для счётчиков и простых операций.
Не подходит для сложной логики (например, изменение коллекций).
```

**Что такое Mutex и Monitor? Кто может выступать в роли монитора?**
> Mutex и Monitor — это механизмы синхронизации, которые помогают управлять доступом к общим ресурсам.\
> Mutex (взаимное исключение) - это примитив синхронизации, который гарантирует, что только один поток может владеть блокировкой в данный момент.
```
Основные свойства:
Бинарный: Может быть либо заблокирован, либо разблокирован.
Владелец: Только поток, который захватил мьютекс, может его освободить.
Системный: Может использоваться между процессами (в отличие от монитора).
```
```
Пример:
val mutex = Mutex()
var sharedCounter = 0

suspend fun incrementCounter() {
    mutex.withLock {  // Автоматически освобождается после выполнения блока
        sharedCounter++
    }
}
```
> Monitor — это высокоуровневый механизм синхронизации, который объединяет: Мьютекс (для входа в критическую секцию) и Условные переменные (Condition Variables) — для ожидания и уведомления потоков
```
Основные свойства:
Привязан к объекту: В Java/Kotlin каждый объект имеет скрытый монитор.
wait(), notify(), notifyAll(): Методы для управления потоками внутри монитора.
Только в одном процессе: Не может использоваться для межпроцессного взаимодействия.
```
```
Пример
val lock = Object()
var conditionMet = false

fun waitForCondition() {
    synchronized(lock) {  // Захватывает монитор объекта lock
        while (!conditionMet) {
            lock.wait()  // Освобождает монитор и ждёт notify()
        }
        // Выполняется, когда conditionMet == true
    }
}

fun changeCondition() {
    synchronized(lock) {
        conditionMet = true
        lock.notifyAll()  // Пробуждает все ожидающие потоки
    }
}
```
_Кто может выступать в роли монитора?_
>В Java/Kotlin любой объект может быть монитором, так как:\
>Каждый объект имеет встроенный мьютекс (вход в synchronized блок).\
>Поддерживает условные переменные (wait(), notify()).\

**Как работает Synchronized и Volatile в Kotlin/Java?**
> Synchronized и volatile используются для управления многопоточностью, но решают разные задачи\
> Synchronized  (блокировка для потокобезопасности) - гарантирует, что только один поток может выполнять блок кода или метод в один момент времени.
```
Как работает?
Когда поток входит в synchronized блок, он захватывает монитор объекта (или класса, если метод static).
Другие потоки блокируются, пока монитор не освободится.
```
> Volatile (видимость изменений между потоками) - гарантирует, что чтение и запись переменной будут видны всем потокам сразу.
```
Как работает?
Без volatile поток может закешировать значение переменной, и изменения из других потоков не будут видны.
С volatile JVM гарантирует "happens-before" — запись в volatile-поле происходит до любого последующего чтения.
```
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
##Архитектура
*Какие виды паттернов существуют(4шт.)*
> Порождающие (Creational) - Помогают создавать объекты
```
Singleton (object в Kotlin) – например, Retrofit клиент или база данных Room:
Factory Method – например, создание ViewModel через ViewModelProvider.Factory.
Builder – например, AlertDialog.Builder в Android:
```
> Структурные (Structural) - Организуют классы и объекты в структуры
```
Adapter – например, RecyclerView.Adapter для списков
Decorator – например, модификация Context с помощью ContextWrapper.
Facade – упрощение работы с API, например, обертка над Retrofit + Room.
```
> Поведенческие (Behavioral) - Управляют взаимодействием между объектами.
```
Observer – LiveData, Flow, интерфейсы слушателей (например, OnClickListener):
State – управление состоянием UI (например, кнопка "Loading"/"Success"/"Error").
Command – обработка нажатий кнопок или событий:
```
> Архитектурные (Architectural) - Определяют структуру всего приложения.
```
MVVM (Model-View-ViewModel) – стандарт для Android с ViewModel и LiveData:
Repository – абстракция для работы с данными (например, комбинация API + БД).
Clean Architecture – разделение на слои (domain, data, presentation).
```
> Популярные Android-специфичные паттерны
```
Dependency Injection (DI) – через Hilt или Koin
ViewBinding/DataBinding – для безопасной работы с UI.
```
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
## Git
*Что такое merge и rebase? Какая разница?*
>  Merge (слияние)
```
Как работает: Создает новый коммит, который объединяет изменения из двух веток. Этот коммит имеет двух родителей (от каждой ветки).
История коммитов: История остается неизменной, добавляется только новый коммит слияния. Это сохраняет полную историю разработки, включая все ветки.
```
> Rebase (перебазирование)
```
Как работает: Перемещает коммиты из одной ветки и применяет их поверх другой ветки, как если бы они были сделаны последовательно. Это создает линейную историю.
История коммитов: История изменяется, коммиты переписываются, чтобы выглядеть так, как будто они были сделаны поверх текущей ветки. Это делает историю более чистой и линейной.
```
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

 Чем отличается Unidirectional Data Flow (UDF) от традиционной архитектуры? 



-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

• Что такое coroutines и как они работают в Kotlin? 
• Что такое Flow и как он отличается от LiveData? 

• 
Коолекции 
• Чем отличаются List, MutableList, Array и ArrayList? 
• 
• Чем отличается suspend функция от обычной? 
Принципы чистого кода: ООП и SOLID 
• Что такое SOLID-принципы и зачем они нужны в программировании? 
Расскажите про каждый из них. 
• Назовите основные принципы объектно-ориентированного 
программирования (ООП). 
• Что такое инкапсуляция и как она достигается в Kotlin? 
• Объясните, что такое наследование и как его реализовать на Kotlin. 
• Что такое полиморфизм и приведите пример его использования. 
• Что такое интерфейсы и абстрактные классы? В чем их разница? 
• Как реализовать Dependency Inversion Principle в Android? 
• Что такое open/closed принцип в Kotlin? 
Основы Android 
• Что такое Android Manifest и для чего он нужен? 
• Каковы основные компоненты Android приложения? 
• Чем отличаются Activity и Fragment? 
• Как управлять жизненным циклом Activity? 
• Как управлять жизненным циклом Fragment? 
• Как сохранить состояние Activity при повороте экрана? 
• Объясните, что такое ViewModel и как его использовать. 
• Что такое LiveData и как его применять? 
• Что такое RecyclerView и как он отличается от ListView? 
• Как происходит взаимодействие между Activity и Fragment? 
• Как работает Intent и какие типы Intent существуют? 
• Что такое Service и для чего он нужен? 
• Что такое Content Provider и как его использовать? 
• Как работает система разрешений в Android? 
• Что такое BroadcastReceiver и как он работает? 
• Как происходит процесс запуска приложения в Android? 
• Как работает back stack в Android? 
• Как обработать нажатие кнопки "Назад" в Activity/Fragment? 
• Чем отличаются Parcelable и Serializable? Какой способ предпочтительнее и 
почему? 
• Какие бывают способы межпроцессного взаимодействия (IPC) в Android? 
• Как реализовать глубокие ссылки (Deep Links) в Android? 
Архитектура Android-приложений 
• Какие существуют архитектурные паттерны для Android приложений? 
• Что такое MVP, MVVM, MVC и в чем их различия? 
• Какой архитектурный паттерн вы предпочитаете и почему? 
• Объясните, как использовать Repository в архитектуре MVVM. 
• Как реализовать слои данных в приложении Android? 
• Что такое Dependency Injection и как его можно реализовать в Android? 
• Что такое Clean Architecture и как она реализуется? 
• Как организовать многомодульную архитектуру в Android? 
• Что такое UseCase в архитектуре приложения? 
• Как использовать EventBus и какие у него альтернативы? 
Жизненный цикл компонентов Android 
• Как работает жизненный цикл Application? 
• Как управлять фоновыми процессами в Android? 
• Как изменился жизненный цикл Activity с Android 10+? 
Jetpack Compose 
• Что такое Jetpack Compose и чем он отличается от традиционного XML
подхода? 
• Как создать простой UI-компонент в Compose? 
• Что такое @Composable функция и как она работает? 
• Как управлять состоянием в Compose? 
• Что такое remember и mutableStateOf в Compose? 
• Как работать с темами и стилями в Compose? 
• Как использовать Modifier в Compose? 
• Что такое LazyColumn и LazyRow и как они работают? 
• Как обрабатывать пользовательские события (клики, свайпы) в Compose? 
• Как интегрировать Compose с существующими View-based компонентами? 
• Что такое SideEffect и как его использовать? 
• Как тестировать UI в Compose? 
• Как работает Composition и Recompositon в Jetpack Compose? 
• Что такое Hoisting в Jetpack Compose? 
• Как работает rememberSaveable? 
• Как анимировать элементы в Compose? 
• Что такое snapshotFlow? 
Dependency Injection (DI) 
• Что такое Dependency Injection и зачем он нужен? 
• Как работает Dagger 2/Hilt в Android? 
• Как создать и использовать модули в Dagger/Hilt? 
• Что такое @Inject, @Module, @Component и @Provides? 
• Как внедрять зависимости в ViewModel с помощью Hilt? 
• Как работать с @Singleton и другими скоупами в Dagger/Hilt? 
• Как тестировать приложения с использованием DI? 
• Чем Hilt лучше Dagger? 
• Как внедрить зависимость в Android Service? 
• Как работает ViewModel Injection в Hilt? 
Многопоточность и конкурентность 
• Как работают Coroutine Scopes? 
• Как использовать Job в Coroutines? 
• В чем разница между suspendCoroutine и suspendCancellableCoroutine? 
• Как работает Channel в Coroutines? 
• Как реализовать backpressure в Flow? 
• В чем разница между Flow и SharedFlow/StateFlow? 
Работа с сетью 
• Как сделать HTTP-запрос в Android? 
• Что такое Retrofit и как его использовать? 
• Как реализовать обработку ошибок в сетевых запросах? 
• Что такое Gson? 
• Как организовать кеширование данных в Retrofit? 
• Чем OkHttp Interceptors отличаются от Retrofit Call Adapters? 
• Как реализовать WebSocket в Android? 
• Как защитить API-ключи в Android? 
Базы данных 
• Что такое SQLite и как его использовать в Android? 
• Что такое Room? 
• Как создавать и управлять миграциями в Room? 
Пользовательский интерфейс (UI) 
• Как работать с ConstraintLayout? 
• Какие виды анимаций в Android вы знаете? 
• Как работает ViewBinding и чем он лучше findViewById? 
• Что такое DataBinding и как его использовать? 
• Что такое LinearLayout и как его использовать? 
• Как создать Custom View в Android? 
• Как управлять состояниями ViewModel с помощью LiveData? 
• Как работает MotionLayout и когда его использовать? 
• Что такое ViewStub и как его использовать? 
• Как создать кастомные атрибуты для View? 
• Как использовать TransitionManager для анимаций? 
• Как работать с Canvas и Custom Drawables? 
Garbage Collector (GC) и управление памятью 
• Как работает Garbage Collector в Android? 
• Какие типы ссылок существуют в Java/Kotlin (сильные, слабые, мягкие, 
фантомные)? 
• Как избежать утечек памяти в Android? 
• Что такое LeakCanary и как его использовать? 
• Как работает WeakReference и когда ее использовать? 
• Как анализировать использование памяти в Android Studio? 
• Что такое OutOfMemoryError и как его предотвратить? 
• Как работает Bitmap и как оптимизировать его использование? 
• Как управлять памятью в приложениях с большим количеством 
изображений? 
• Что такое onTrimMemory и как его использовать? 
Context в Android 
• Что такое Context в Android и для чего он нужен? 
• Чем отличается ApplicationContext от ActivityContext? 
• Когда использовать ApplicationContext, а когда ActivityContext? 
• Как передавать Context между компонентами? 
• Какие проблемы могут возникнуть при неправильном использовании 
Context? 
• Что такое ContextWrapper и как его использовать? 
• Как избежать утечек памяти, связанных с Context? 
Память в Android 
• Как работает управление памятью в Android? 
• Что такое Heap и Stack в контексте Android? 
• Как работает Bitmap и как оптимизировать его использование? 
• Что такое Memory Profiler в Android Studio и как его использовать? 
• Как избежать утечек памяти в Android? 
• Что такое onLowMemory и как его использовать? 
• Как работает кэширование в Android и как его правильно реализовать? 
• Что такое LargeHeap и когда его использовать? 
Тестирование 
• Как писать unit-тесты для ViewModel? 
• Что такое Mockito и как его использовать? 
• Как тестировать Coroutines? 
• Как писать UI-тесты с помощью Espresso? 
• Как тестировать Compose-компоненты? 
• Что такое JUnit и как его использовать? 
Прочее 
• Как использовать SharedPreferences для хранения данных? 
• Как работают и чем отличаются Activity и Service? 
• Как управлять памятью и предотвращать утечки в Android? 
• Что такое WorkManager и когда его использовать? 
• Как использовать WorkManager для фоновых задач? 
• Что такое JobScheduler и как его использовать? 
• Как работать с NotificationManager? 
• Как использовать BiometricPrompt для биометрической аутентификации? 
• Что такое Deep Links и как их реализовать? 
• Как работать с CameraX? 
• Как использовать Location Services в Android? 
• Что такое App Bundles и зачем они нужны? 
• Как работает Dynamic Delivery? 
• Как использовать Firebase в Android-приложениях? 
Какие коллекции есть в Kotlin/Java?
 Чем List, Set и Map отличаются друг от друга?
 В чем разница между ArrayList и LinkedList?
 Какие виды Set существуют и чем они отличаются?
 Чем HashMap отличается от TreeMap и LinkedHashMap?
 Чем mutableListOf() отличается от listOf()?
 Что выбрать: ArrayList или MutableList?
 Как работает map, filter и flatMap в Kotlin?
 Что такое Sequence, и когда его стоит использовать?
 Как работает groupBy в Kotlin?
 Как эффективно конвертировать List в Set или Map?
