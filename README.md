# Quest
_Список вопросов для самоподготовки к собеседованиям_
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

<details>
  <summary>Коллекции</summary>

**Какие коллекции есть в Kotlin/Java?**
> List,Set,Map\
_Чем отлиаются друг от друга_
> ну ты серьезно, это расписывать собралась?\
• Чем отличаются List, MutableList, Array и ArrayList? 
 Чем List, Set и Map отличаются друг от друга?
 В чем разница между ArrayList и LinkedList?
 Какие виды Set существуют и чем они отличаются?
 Чем HashMap отличается от TreeMap и LinkedHashMap?
 Чем mutableListOf() отличается от listOf()?
 Что выбрать: ArrayList или MutableList?
 Как работает map, filter и flatMap в Kotlin?
 Что такое Sequence, и когда его стоит использовать?
 Как работает groupBy в Kotlin?
 Как эффективно конвертировать List в Set или Map?

</details>

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
<details>
  <summary>Основы Kotlin</summary>
## Основы Kotlin 
**Какие основные отличия Kotlin от Java? Преимущества Kotlin**
 > NullSafety, сокращение кодовой базы на 20%, companion object, data-class

**В чём заключается разница в Exeption в Kotlin и Java**
> Java - checked и unchecked, где checked - обязательно для обработки - иначе программа не скомпилирется\
> В Kotlin все исключения являются uncheked - т.е необязательные для обработки, программа скомпилируется в любом случае.\
> Однако, если разработчик решит не обрабатывать исключения, это может приводить к нежелательным последствиям (краши, ошибки)\

**Отличие при проверке на равенсто, "==", "===" и equals()**
 _Java_\
> Примитивы - при == сранивают значения и ссылки.\
> Объекты - при === сравнивает значения, при ==  только ссылки.\
> Новый объект - новая ссылка, даже если значения индетичны.\
_Kotlin_\
> Примитивы - == и === сравнивает данные,\
> Объекты - при == сравнивают данные, при === сравнивает ссылки.\
> Equals() - индентичен "==" (но есть нюансы с Double и Float) и для примитивов и для объектов.\

**Модификаторы доступа**
> Private - видимость только в пределах самого класса\
> Protected - видимость в пределах класса и наследников\
> Internal - видимость в пределах одного модуля\
> Public - видимость в пределах всего приложения

**Что такое null safety в Kotlin и как это работает?**
> Возможность избежать краша приложения из-за NPE\

_Как это работает_
> По умолчанию все типы в Kotlin - не нуллабельны\
> При инициализации переменной мы можем объявить ее как null_ельную, т.е возможно содержащую Null\
> Для этого используетя символ "?"\
```
val example:String? = null
> строка null? но это не вызовет ошбибку компилятора
```
_Почему это удобно?_
> Может быыть такая ситуация, что мы не знаем, будет ли переменная содержать значения или нет (например сервер возвращает объект где некоторые поля заполнены, а некоторые нет)\
> С помощью null safety мы можем избежать краша Npe при обработке ответа\
```
val newUser = user?.let {it.user}
> Если user не Null, мы запишем данные, в противном случае не будем делать ничего
```
```
val newUser = it.user?:"Васька"
> В данном случае если ответ будет не null - мы запишем данные из it.user, в противном случае в переменную упадет значение "Васька"
```
_Что делать если очень хочется Npe?_
> Использовать "!!" - таким образом, мы говорим компилятору: "Тут точно не null, отвечаю". Однако краши из-за Npe - теперь ответсвенность разработчика\

**Как объявить переменную в Kotlin? В чем разница между val и var?**
> С помощью ключевых слов val и var.  Неизменяемая и изменяемая переменная.\
> у Val есть только геттер, у var - геттер и сеттер
> Val значение которое можно назначить во время работы программы, const val - во время компиляциии программы\

**Объясните, что такое data class в Kotlin.**
> Удобный класс, в основном использую для хранения данных. В таком классе переопределены методы - ToString(), Equals(), HashCode(), Component().\
> Почему это удобно? Упрощние сравнение объектов и их сериализация, автоматически сгненнерированы сеттеры и геттеры для каждого поля\
> Метод copy() - который позволяет создать новый объект, интетичный предыдущему, но с изменнеными значениями некоторых полей по желанию\
_Какие существуют ограничения для таких кслассов?_
> Классы данных не могут быть abstract, open, sealed или inner.\
> Должно быть хоть одно поле в конструкторе - var или val\
_Можно ли наследоваться от таких классов?_\
> Нет, они по умолчанию final, но может наследоваться сам\

Как объявить функцию в Kotlin? 
> Ключевое слово fun

**Что такое companion object?**
> Анонимный класс, объявленный внутри класса, в некоторым роде аналог статическиз полей из Java\
>  Kotlin создает статическое поле внутри класса, которое хранит экземпляр анонимного объекта\
```
Когда использовать?
Для констант (например, const val TAG = "MyClass").
Для фабричных методов (например, create()).
Для реализации паттернов (Singleton, Factory и др.).
Для доступа к приватным членам класса извне.
```

**Что такое sealed class и когда их использовать?**
> Усовершенствованные enum, класс в который можно положить и другие class и объекты, имеет ограниченное наследование\
> У sealed класса могут быть наследники, но все они должны находиться в одном пакете с этим классом. Изолированный класс "открыт" для наследования по умолчанию, указывать слово open не требуется.\
> Наследники могут быть любого типа: data class, объектом, обычным классом, другим sealed классом. Классы, которые расширяют наследников sealed класса могут находиться где угодно.\
> Изолированные классы абстрактны и могут содержать в себе абстрактные компоненты.\
> Не могут быть inner.\

_Какие отличия между enum и seaed-class?_
> enum представляет собой конечный список значений, которые объявляются заранее в момент компиляции, и не могут быть расширены или изменены во время выполнения программы
> sealed class позволяет определять ограниченный набор значений, но эти значения могут быть расширены в будущем

**Как работает when в Kotlin?**
> Это аналог switch-case из java
```
Главные отличия от switch-case
Поддерживает любые условия, а не только константы.
Может работать без аргумента (аналог if-else if).
Может возвращать значение.
```
**Как создать singleton в Kotlin?**
> С помощью ключевого слово object\
> плюсы:\
> - Ленивая инициализация при первом обращении\
> - Потокобезопасность\
_Что если нужен синглтон с параметрами?_\
> У object нет конструктора, для синглтона с параметрами, можно использовать class+lazy\
```
class Singleton private constructor(val config: String) {
    companion object {
        val instance: Singleton by lazy { Singleton("default") }
    }
}
```
> или
```
class Singleton private constructor(val config: String) {
    companion object {
        @Volatile private var instance: Singleton? = null
        private val lock = Any()

        fun getInstance(config: String): Singleton {
            return instance ?: synchronized(lock) {
                instance ?: Singleton(config).also { instance = it }
            }
        }
    }

    fun doSomething() {
        println("Config: $config")
    }
}

// Использование
fun main() {
    val singleton = Singleton.getInstance("test")
    singleton.doSomething()  // Config: test
}
```
**Что такое Unit в Kotlin?**
> Аналог Void, то что возвращается из функции, в которой не указан возвращаемый тип.\
> Unit может использоваться с дженериками\

**Как работает lateinit и lazy?** 
> Оба ленивая инициализация
_lateinit_
> var, и обязуемся проинициализировать до первого обращения\
> если не проинициализируем - упадем\
_lazy_
> val и инициализируется автоматически при первом обращении
> не упадем, потому что инициализируем при первом обращеннии

**Как работает smart cast в Kotlin?**
> Умное приведение типов через специальное выражение is\
> Компилятор запоминает тип, и обращается к нему в области видисоости как к определенному\
```
if (cast is String){
тут переменная каст, будет считаться как String
 cast.lenght()
}
```
> as - явное приведение, при ошибке приведению типов бросит исключение

**Что такое интерфейсы и абстрактные классы? В чем их разница?**
>Оба понятия используются для абстракции (описания поведения без реализации), но имеют ключевые различия.\
>Абстрактные класс - класс, который нельзя создать напрямую (только через наследование). Может содержать:\
>абстрактные методы (без реализации, abstract fun),\
>обычные методы (с реализацией),\
>поля (свойства).\
>Использовать когда несколько классов должны иметь общую базовую логику.
>Интерфейс - контракт методов
</details>

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
<details>
  <summary>Дженерики\Лямбды\Хай-левел и экстеншн функции</summary>
## Дженерики\Лямбды\Хай-левел и экстеншн функции

**Как использовать функции расширения в Kotlin?**
```
 fun Fragment.toast(@StringRes stringRes: Int) {
    Toast.makeText(requireContext(), stringRes, Toast.LENGTH_SHORT).show()}
```
>  теперь во фрагменте можно вызвать тост, только словом toast

**Что такое inline,reified, noinline и crossinline?*
> Это модификаторы для работы с лямбда - выражениями

_inline_
> Встроенная функция - встаивает код лямбды прямо вместо вызова функции - таким образом увеличивая оптимизацию

_noinline_
> Запрещает встраивание конкретной лямбды в inline-функции.Зачем: Если лямбда передаётся в другую не-inline функцию.Если нужно сохранить лямбду как объект (например, для отложенного выполнения).

_crossinline_
> Запрещает return в лямбде (локальный)

_reified_
> Делает generics конкретными. Позволяет использовать тип T как реальный (а не стираемый) внутри inline-функции.


**В чем разница между let, apply, also, run, with?**

_let_
> Для безопасной работы с nullable-объектами.\
> ("Пусть сделают с объетом что-то")\
> Выполнить операции над объектом и вернуть результат лямбды.\
```
val example = uri?.let{it.uri}
> "Eсли uri не пустой, пусть example присваивается it.uri"
```
_apply_
> Для инициализации или конфигурации объекта.\
>("Настрой объект так и верни")\
> Настроить объект (изменить его свойства) и вернуть сам объект (this).\
```
val result = object.apply { this -> ... }
```
_also_
> Для отладки или логгирования или когда нужно выполнить действие, но сохранить объект без изменений.
> ("Также сделай с объектом вот это и верни, но не сохраняй")
```
val list = mutableListOf(1, 2, 3).also {
    println("List before add: $it")  // Побочный эффект
    it.add(4)
}
```
_run_
> Работает как комбинация let + with: выполняет блок кода и возвращает результат лямбды.
> ??????

_with_
> ("Работай в контексте вот этого-вот")

**Что такое higher-order функции?**
> Higher-order functions (функции высшего порядка) — это функции, которые работают с другими функциями принимая их как аргументы или возвращая их как результат 
</details>

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
<details>
  <summary>👉Flow</summary>
##Flow
**Какие виды flow существуют**
> Горячие и холодные flow
Холодные флоу (flow )- не будут работать если не подписаться (collect), как только отдадут все занчения - закончат выполнение, новая подписка - новый поток, нет подписчиков - нет потока
Горячие флоу (stateFlow) - работают независимо от наличия подписчиков, продолжают работу незавичимо есть данные или нет, никогда не завершается

**Что такое Flow и как он отличается от LiveData?**
> Flow - ассинхронный поток данных

</details>

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
<details>
  <summary>Android SDK </summary>
## Android SDK
**Каковы основные компоненты Android приложения?**
> Activity, Services, Broadcast Receiver, Content Provider 

**Расскажи что происходит при запуске приложения**
>1. Запуск процесса
```
Когда пользователь запускает приложение, операционная система Android создает новый процесс (если он еще не существует) и выделяет для него ресурсы.
Каждое приложение в Android работает в изолированном процессе с собственной виртуальной машиной (ART/Dalvik).
```
>2. Загрузка приложения
```
Система загружает код приложения из APK-файла.
Загружаются ресурсы приложения (изображения, строки, макеты и т.д.).
```
>3. Создание объекта Application
```
Если в приложении есть пользовательский класс, унаследованный от Application, система создает его экземпляр.
В этом классе можно выполнить инициализацию глобальных переменных или библиотек (например, Firebase, аналитика и т.д.).
```
>4. Запуск стартовой Activity
```
Система определяет, какая Activity должна быть запущена первой (указана в манифесте в теге <intent-filter> с действием MAIN и категорией LAUNCHER).
Создается экземпляр этой Activity.
```
> 5. Жизненный цикл Activity
```
OnCreate() - onStart() - OnResume()
```
> 6.  Отображение интерфейса\Работа приложения\Фоновые процессы
> 7.  Заверншение работы


**Как реализовать глубокие ссылки (Deep Links) в Android?**
> Глубокие ссылки (Deep Links) позволяют открывать определенные экраны или контент в приложении из внешних источников (веб).\
> Подключаем manifest -  добавляем intent-фильтры\
> Обрабатываем в коде




 Что такое Android Manifest и для чего он нужен? 
• 
• Чем отличаются Activity и Fragment? 
• Как управлять жизненным циклом Activity? 
• Как управлять жизненным циклом Fragment? 
• Как сохранить состояние Activity при повороте экрана? 
• Объясните, что такое ViewModel и как его использовать. 
• Что такое LiveData и как его применять? 
• Что такое RecyclerView и как он отличается от ListView? 
• Как происходит взаимодействие между Activity и Fragment? 
• Как работает Intent и какие типы Intent существуют? 
• Что такое Service и для чего он нужен? 
• Что такое Content Provider и как его использовать? 
• Как работает система разрешений в Android? 
• Что такое BroadcastReceiver и как он работает? 
• Как происходит процесс запуска приложения в Android? 
• Как работает back stack в Android? 
• Как обработать нажатие кнопки "Назад" в Activity/Fragment? 
• Чем отличаются Parcelable и Serializable? Какой способ предпочтительнее и 
почему? 
• Какие бывают способы межпроцессного взаимодействия (IPC) в Android? 
• Как реализовать глубокие ссылки (Deep Links) в Android? 
• Как работают и чем отличаются Activity и Service? 
</details>

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
<details>
  <summary>Fragments</summary>
## Fragments
**Почему не стоит создавать конструкторы с параметрами для фрагментов?**
> При пересоздании экрана (по сути уничтожении) все данные также уничтожаться – потеря параметров, а также возможно словить краш
\
</details>

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
<details>
  <summary>Service</summary>
## Service
**В каком потоке работает Service по умолчанию?**
> Все на главном кроме Intent и JobIntent 
\
</details>

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
<details>
  <summary>View\Ui</summary>
## View\Ui

**Как создать Custom View в Android?**
> Наследуем класс от View
```
class MyCustomView @JvmOverloads constructor(
    context: Context,
    attrs: AttributeSet? = null,
    defStyleAttr: Int = 0
) : View(context, attrs, defStyleAttr) { ...}
```
> В init обрабатываем кастомные атрибуту
```
    init {
        // Обработка кастомных атрибутов
        attrs?.let {
            val typedArray = context.obtainStyledAttributes(
                it,
                R.styleable.MyCustomView,
                defStyleAttr,
                0
            )

            customColor = typedArray.getColor(
                R.styleable.MyCustomView_customColor,
                Color.RED
            )
            customText = typedArray.getString(
                R.styleable.MyCustomView_customText
            ) ?: "Default"

            typedArray.recycle()
        }
    }
```
> Кастомные атрибуты можно установит через xml
```
<resources>
    <declare-styleable name="MyCustomView">
        <attr name="customColor" format="color"/>
        <attr name="customText" format="string"/>
        <attr name="customTextSize" format="dimension"/>
    </declare-styleable>
</resources>
```
> Переопределяем необходимые методы
```
override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {
    val minWidth = suggestedMinimumWidth + paddingLeft + paddingRight
    val minHeight = suggestedMinimumHeight + paddingTop + paddingBottom
    
    val width = resolveSize(minWidth, widthMeasureSpec)
    val height = resolveSize(minHeight, heightMeasureSpec)
    
    setMeasuredDimension(width, height)
}

override fun onDraw(canvas: Canvas) {
    super.onDraw(canvas)
    
    // Рисуем фон
    canvas.drawColor(customColor)
    
    // Рисуем текст по центру
    val textWidth = textPaint.measureText(customText)
    val x = (width - textWidth) / 2
    val y = (height - textPaint.textSize) / 2 + textPaint.textSize
    
    canvas.drawText(customText, x, y, textPaint)
}
```

 Как работать с ConstraintLayout? 
 Какие виды анимаций в Android вы знаете? 
• Как работает ViewBinding и чем он лучше findViewById? 
• Что такое DataBinding и как его использовать? 
• Что такое LinearLayout и как его использовать? 
• Как создать Custom View в Android? 
• Как управлять состояниями ViewModel с помощью LiveData? 
• Как работает MotionLayout и когда его использовать? 
• Что такое ViewStub и как его использовать? 
• Как создать кастомные атрибуты для View? 
• Как использовать TransitionManager для анимаций? 
• Как работать с Canvas и Custom Drawables? 
</details>

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
<details>
  <summary>ЖЦ </summary>
## ЖЦ 
**ЖЦ View**
> Created (Создание): View создается программно или загружается из XML-макета. На этом этапе еще не произошло его отображение на экране.\
> Attached (Присоединение): View присоединяется к родительскому контейнеру (например, к Layout). На этом этапе начинают применяться параметры размещения и размеры.\
> Measured (Измерение): Система измеряет размеры и расположение View в контейнере, чтобы правильно разместить его на экране. Этот этап определяет размеры View и его дочерних элементов.\
> Layout (Размещение): View размещается внутри родительского контейнера с учетом измерений, определенных на предыдущем этапе.\
> Draw (Отрисовка): View отрисовывается на экране. На этом этапе происходит фактическое отображение элемента на экране, используя его графические ресурсы и атрибуты.\
> Detached (Отсоединение): View отсоединяется от родительского контейнера. Это может произойти при удалении View из иерархии или при временном скрытии.\
> Destroyed (Уничтожение): View уничтожается, освобождая память и ресурсы, занимаемые этим элементом. Этот этап может наступить при завершении работы Activity или в случае явного удаления View.\

**Какие методы жизненного цикла активити и в каком порядке вызовутся при повороте устройства из портретной в альбомную ориентацию?**
> Учитывая что экран уже активен (в состоянии onResume): onPause – OnStop – OnDestroy –OnCreate – OnStart - onResume



Жизненный цикл компонентов Android 
• Как работает жизненный цикл Application? 
• Как управлять фоновыми процессами в Android? 
• Как изменился жизненный цикл Activity с Android 10+? 
</details>

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
<details>
  <summary>Compose</summary>
## Compose
**Что такое remember и mutableStateOf в Compose?**
> mutableStateOf - это функция, которая создает наблюдаемое состояние и при изменении значения автоматически вызывает рекомпозицию всех зависимых от него композаблов\
> remember - это функция, которая сохраняет значение между рекомпозициями. Без remember значение будет сбрасываться при каждой рекомпозиции
Jetpack Compose 
• Что такое Jetpack Compose и чем он отличается от традиционного XML
подхода? 
• Как создать простой UI-компонент в Compose? 
• Что такое @Composable функция и как она работает? 
• Как управлять состоянием в Compose? 
• Что такое remember и mutableStateOf в Compose? 
• Как работать с темами и стилями в Compose? 
• Как использовать Modifier в Compose? 
• Что такое LazyColumn и LazyRow и как они работают? 
• Как обрабатывать пользовательские события (клики, свайпы) в Compose? 
• Как интегрировать Compose с существующими View-based компонентами? 
• Что такое SideEffect и как его использовать? 
• Как тестировать UI в Compose? 
• Как работает Composition и Recompositon в Jetpack Compose? 
• Что такое Hoisting в Jetpack Compose? 
• Как работает rememberSaveable? 
• Как анимировать элементы в Compose? 
• Что такое snapshotFlow? 
  </details>
  
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
<details>
  <summary>👉рхитектура и принципы</summary>
## Архитектура и принципы
**Что такое MVP, MVVM, MVC, MVI и в чем их различия?**
> Это архитекутрные паттерны, для помощи организации кода в приложении\
> MVC - Model-View-Controller (Модель (бизнес-логика) - View (UI) - Коннтроллер(обрабатывает пользовательский ввод, управляет Model и обновляет View.) Проблемы:если логика накапливается в Controller, его сложно поддерживать.\
```
Как работает
Пользователь взаимодействует с View (например, нажимает кнопку).
View передает действие в Controller.
Controller обновляет Model.
Model уведомляет View об изменениях (через Observer или прямое обновление).
```
> MVP - Model-View-Presenter (старая система)
```
Как работает
Пользователь взаимодействует с View.
View делегирует действие Presenter.
Presenter обновляет Model.
Model возвращает данные Presenter.
Presenter обновляет View.
```
> MVVM -Model-ViewModel-Model
```
Как работает
Пользователь взаимодействует с View.
View делегирует действие ViewModel (через команды или привязки).
ViewModel обновляет Model.
Model может уведомить ViewModel (если используется Observer).
ViewModel автоматически обновляет View через data binding (например, в WPF, Android Jetpack, SwiftUI).
```
> MVI - Model - View - Intet
```
Как работает MVI?\
Пользователь совершает действие → View отправляет Intent.
Система обрабатывает Intent (например, делает API-запрос).
Результат преобразуется в новое состояние (Model).
View автоматически обновляется на основе нового состояния.
```
*Какие виды паттернов существуют(4шт.)*
> Порождающие (Creational) - Помогают создавать объекты
```
Singleton (object в Kotlin) – например, Retrofit клиент или база данных Room:
Factory Method – например, создание ViewModel через ViewModelProvider.Factory.
Builder – например, AlertDialog.Builder в Android:
```
> Структурные (Structural) - Организуют классы и объекты в структуры
```
Adapter – например, RecyclerView.Adapter для списков
Decorator – например, модификация Context с помощью ContextWrapper.
Facade – упрощение работы с API, например, обертка над Retrofit + Room.
```
> Поведенческие (Behavioral) - Управляют взаимодействием между объектами.
```
Observer – LiveData, Flow, интерфейсы слушателей (например, OnClickListener):
State – управление состоянием UI (например, кнопка "Loading"/"Success"/"Error").
Command – обработка нажатий кнопок или событий:
```
> Архитектурные (Architectural) - Определяют структуру всего приложения.
```
MVVM (Model-View-ViewModel) – стандарт для Android с ViewModel и LiveData:
Repository – абстракция для работы с данными (например, комбинация API + БД).
Clean Architecture – разделение на слои (domain, data, presentation).
```
> Популярные Android-специфичные паттерны
```
Dependency Injection (DI) – через Hilt или Koin
ViewBinding/DataBinding – для безопасной работы с UI.
```

Принципы чистого кода: ООП и SOLID 
• Что такое SOLID-принципы и зачем они нужны в программировании? 
Расскажите про каждый из них. 
• Назовите основные принципы объектно-ориентированного 
программирования (ООП). 
• Что такое инкапсуляция и как она достигается в Kotlin? 
• Объясните, что такое наследование и как его реализовать на Kotlin. 
• Что такое полиморфизм и приведите пример его использования. 
• Что такое интерфейсы и абстрактные классы? В чем их разница? 
• Как реализовать Dependency Inversion Principle в Android? 
• Что такое open/closed принцип в Kotlin? 
 Какие существуют архитектурные паттерны для Android приложений? 
• Что такое MVP, MVVM, MVC и в чем их различия? 
• Какой архитектурный паттерн вы предпочитаете и почему? 
• Объясните, как использовать Repository в архитектуре MVVM. 
• Как реализовать слои данных в приложении Android? 
• Что такое Dependency Injection и как его можно реализовать в Android? 
• Что такое Clean Architecture и как она реализуется? 
• Как организовать многомодульную архитектуру в Android? 
• Что такое UseCase в архитектуре приложения? 
• Как использовать EventBus и какие у него альтернативы? 
 Чем отличается Unidirectional Data Flow (UDF) от традиционной архитектуры? 
  </details>
  
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
<details>
  <summary>👉  Context</summary>
## Context
Context в Android 
• Что такое Context в Android и для чего он нужен? 
• Чем отличается ApplicationContext от ActivityContext? 
• Когда использовать ApplicationContext, а когда ActivityContext? 
• Как передавать Context между компонентами? 
• Какие проблемы могут возникнуть при неправильном использовании 
Context? 
• Что такое ContextWrapper и как его использовать? 
• Как избежать утечек памяти, связанных с Context? 
    </details>
    
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
<details>
  <summary>👉Dagger\Di</summary>
## Dagger\Di

**Отличие @Provides от @Bind**
> Bind - Используется для связывания интерфейса/абстрактного класса с его реализацией\
> Например
```
@Module
abstract class StorageModule {
    @Binds
    abstract fun bindStorage(impl: SharedPrefStorage): Storage  // Storage — интерфейс
}
```
> Provide - Используется в модулях (@Module) для создания экземпляров зависимостей\
> Например:
```
@Module
class NetworkModule {
    @Provides
    fun provideOkHttpClient(): OkHttpClient {
        return OkHttpClient.Builder()
            .connectTimeout(30, TimeUnit.SECONDS)
            .build()
    }
}
> Создали экхемпляр класса okkhttp\
> Метод с @Provides выполняет код и возвращает готовый объект.
```
_Ключевые отличия_\
|Характеристика	    | @Provides	                                      || @Binds\
|Тип модуля         |	Обычный класс (class)                           ||	Абстрактный класс/интерфейс (abstract class/interface)\
|Логика создания    |	Содержит код (например, return OkHttpClient())	 || Только объявление (например, bindStorage(impl: SharedPrefStorage): Storage)\
|Использование      |	Для любых зависимостей                          ||	Только для интерфейсов/абстрактных классов\
|Производительность |	Медленнее (вызов метода)                        ||	Быстрее (нет вызова метода)\
|Гибкость	          | Можно добавить любую логику                     ||	Только связь интерфейса с реализацией\


 Что такое Dependency Injection и зачем он нужен? 
• Как работает Dagger 2/Hilt в Android? 
• Как создать и использовать модули в Dagger/Hilt? 
• Что такое @Inject, @Module, @Component и @Provides? 
• Как внедрять зависимости в ViewModel с помощью Hilt? 
• Как работать с @Singleton и другими скоупами в Dagger/Hilt? 
• Как тестировать приложения с использованием DI? 
• Чем Hilt лучше Dagger? 
• Как внедрить зависимость в Android Service? 
• Как работает ViewModel Injection в Hilt? 
    </details>

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
<details>
  <summary> Многопоточность</summary>
## Многопоточность
**Что такое процесс? Что такое поток?**
> Процесс — это программа в памяти со своей изолированной средой. Процессы используются реже (например, для запуска внешних утилит через ProcessBuilder).\
> Поток — это "легкий" процесс, выполняющийся внутри процесса и делящий его ресурсы. В Java/Kotlin обычно работают с потоками (Thread, корутины, ExecutorService).\
> Олин процесс, много потоков

**Как работает Atomic в Kotlin?**
> Atomic-классы предоставляют потокобезопасные операции над переменными без использования блокировок (synchronized). Они основаны на атомарных инструкциях процессора (CAS — Compare-And-Swap).
```
Atomic — это потокобезопасные классы для операций над числами и ссылками.
Работают через CAS (Compare-And-Swap), без блокировок.
Лучше synchronized для счётчиков и простых операций.
Не подходит для сложной логики (например, изменение коллекций).
```

**Что такое Mutex и Monitor? Кто может выступать в роли монитора?**
> Mutex и Monitor — это механизмы синхронизации, которые помогают управлять доступом к общим ресурсам.\
> Mutex (взаимное исключение) - это примитив синхронизации, который гарантирует, что только один поток может владеть блокировкой в данный момент.
```
Основные свойства:
Бинарный: Может быть либо заблокирован, либо разблокирован.
Владелец: Только поток, который захватил мьютекс, может его освободить.
Системный: Может использоваться между процессами (в отличие от монитора).
```
```
Пример:
val mutex = Mutex()
var sharedCounter = 0

suspend fun incrementCounter() {
    mutex.withLock {  // Автоматически освобождается после выполнения блока
        sharedCounter++
    }
}
```
> Monitor — это высокоуровневый механизм синхронизации, который объединяет: Мьютекс (для входа в критическую секцию) и Условные переменные (Condition Variables) — для ожидания и уведомления потоков

```
Основные свойства:
Привязан к объекту: В Java/Kotlin каждый объект имеет скрытый монитор.
wait(), notify(), notifyAll(): Методы для управления потоками внутри монитора.
Только в одном процессе: Не может использоваться для межпроцессного взаимодействия.
```
```
Пример
val lock = Object()
var conditionMet = false

fun waitForCondition() {
    synchronized(lock) {  // Захватывает монитор объекта lock
        while (!conditionMet) {
            lock.wait()  // Освобождает монитор и ждёт notify()
        }
        // Выполняется, когда conditionMet == true
    }
}

fun changeCondition() {
    synchronized(lock) {
        conditionMet = true
        lock.notifyAll()  // Пробуждает все ожидающие потоки
    }
}
```
_Кто может выступать в роли монитора?_
>В Java/Kotlin любой объект может быть монитором, так как:\
>Каждый объект имеет встроенный мьютекс (вход в synchronized блок).\
>Поддерживает условные переменные (wait(), notify()).\

**Как работает Synchronized и Volatile в Kotlin/Java?**
> Synchronized и volatile используются для управления многопоточностью, но решают разные задачи\
> Synchronized  (блокировка для потокобезопасности) - гарантирует, что только один поток может выполнять блок кода или метод в один момент времени.
```
Как работает?
Когда поток входит в synchronized блок, он захватывает монитор объекта (или класса, если метод static).
Другие потоки блокируются, пока монитор не освободится.
```
> Volatile (видимость изменений между потоками) - гарантирует, что чтение и запись переменной будут видны всем потокам сразу.
```
Как работает?
Без volatile поток может закешировать значение переменной, и изменения из других потоков не будут видны.
С volatile JVM гарантирует "happens-before" — запись в volatile-поле происходит до любого последующего чтения.
```

• Что такое coroutines и как они работают в Kotlin? 
• Что такое Flow и как он отличается от LiveData? 
• Чем отличается suspend функция от обычной? 
• Как работают Coroutine Scopes? 
• Как использовать Job в Coroutines? 
• В чем разница между suspendCoroutine и suspendCancellableCoroutine? 
• Как работает Channel в Coroutines? 
• Как реализовать backpressure в Flow? 
• В чем разница между Flow и SharedFlow/StateFlow? 
  
</details>

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
<details>
  <summary>Работа с сетью: Retrofit\Okhttp\Json</summary>
## Работа с сетью: Retrofit\Okhttp\Json
 Как сделать HTTP-запрос в Android? 
• Что такое Retrofit и как его использовать? 
• Как реализовать обработку ошибок в сетевых запросах? 
• Что такое Gson? 
• Как организовать кеширование данных в Retrofit? 
• Чем OkHttp Interceptors отличаются от Retrofit Call Adapters? 
• Как реализовать WebSocket в Android? 
• Как защитить API-ключи в Android? 
  </details>
  
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
<details>
  <summary>БД и хранение данных</summary>
## БД и хранение данных
• Что такое SQLite и как его использовать в Android? 
• Что такое Room? 
• Как создавать и управлять миграциями в Room? 
• Как использовать SharedPreferences для хранения данных? 
    </details>
    
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
<details>
  <summary>Память</summary>
## Память

• Как работает управление памятью в Android? 
• Что такое Heap и Stack в контексте Android? 
• Как работает Bitmap и как оптимизировать его использование? 
• Что такое Memory Profiler в Android Studio и как его использовать? 
• Как избежать утечек памяти в Android? 
• Что такое onLowMemory и как его использовать? 
• Как работает кэширование в Android и как его правильно реализовать? 
• Что такое LargeHeap и когда его использовать? 
• Как работает Garbage Collector в Android? 
• Какие типы ссылок существуют в Java/Kotlin (сильные, слабые, мягкие, 
фантомные)? 
• Как избежать утечек памяти в Android? 
• Что такое LeakCanary и как его использовать? 
• Как работает WeakReference и когда ее использовать? 
• Как анализировать использование памяти в Android Studio? 
• Что такое OutOfMemoryError и как его предотвратить? 
• Как работает Bitmap и как оптимизировать его использование? 
• Как управлять памятью в приложениях с большим количеством 
изображений? 
• Что такое onTrimMemory и как его использовать? 
  </details>
  
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
<details>
  <summary>Gradle</summary>

## **Что такое Gradle?**

<details>
  <summary></summary>
Gradle — это система автоматизации сборки проектов, которая использует Groovy или Kotlin DSL (Domain-Specific Language) для написания скриптов
    
  </details>
    
## **Чем gradle отличается от Maven, Ant?**\
Ключевые отличия\
_Язык конфигурации_\
Gradle использует Groovy/Kotlin (более читаемый и гибкий). (Maven/Ant используют XML (многословный и менее удобный).)\
_Производительность_\
Gradle быстрее благодаря инкрементным сборкам и кешу. (Maven и Ant пересобирают всё каждый раз.)\
_Управление зависимостями_\
Maven и Gradle поддерживают автоматическое разрешение зависимостей. (Ant требует ручного скачивания и подключения библиотек.)\
_Расширяемость_\
Gradle позволяет легко создавать кастомные задачи и плагины. (В Maven сложнее добавлять нестандартные шаги сборки.)

## **Как работает Gradle (основные компоненты: скрипты, задачи, зависимости, плагины)?**\
_а. Скрипты сборки (build.gradle и settings.gradle)_\
Gradle использует два основных файла:\
1. build.gradle - главный файл конфигурации проекта, который содержит:\
 ͘  Зависимости (библиотеки, которые использует проект).\
 ͘  Плагины (дополнительные функции, например, Java, Android, Spring Boot).\
 ͘  Задачи (действия, которые выполняются при сборке).\
2.settings.gradle - Определяет структуру проекта.\
_b. Задачи (Tasks)_\
Задача (Task) — это атомарное действие, которое Gradle выполняет (например, компиляция, тестирование, упаковка в JAR).\
Типы задач:\
- Стандартные (предопределены плагинами, например, compileJava, test).\
- Кастомные (создаются вручную).\
Пример задач
```
tasks.register("buildReport") {
    group = "reporting" // Группа для удобства
    description = "Генерирует отчёт сборки"
    doLast {
        println("Отчёт готов!")
    }
}
```
_c.Зависимости_
Gradle автоматически скачивает библиотеки из репозиториев (Maven Central, JCenter и др.)\
Типы зависимостей:\
- implementation — для основного кода.\
- testImplementation — только для тестов.\
- compileOnly — зависимости, нужные только для компиляции (не попадают в итоговый билд)\
Пример зависимости:
```
dependencies {
    implementation("org.apache.commons:commons-lang3:3.12.0") // Основная зависимость
    testImplementation("junit:junit:4.13.2") // Только для тестов
}
```

_d.Плагины_
Плагины добавляют готовую функциональность (например, поддержку Java, Spring, Docker)\
Типы:\
-Офицциальные\
-Кастомные\
Пример:
```
plugins {
    id("java") // Плагин для Java
    id("org.springframework.boot") version "2.7.0" // Spring Boot
}
```
_Как Gradle выполняет сборку?_
- Чтение конфигурации: Gradle анализирует settings.gradle и build.gradle.\
- Создание Directed Acyclic Graph (DAG) задач: Определяет порядок выполнения задач.\
- Загрузка зависимостей: Качает библиотеки из указанных репозиториев.\
- Выполнение задач: Запускает задачи в правильном порядке (например, compileJava → test → build).\
- Кэширование результатов: Ускоряет повторные сборки.\

## **Что такое Gradle Daemon и зачем он нужен?**\
Gradle Daemon (демон Gradle) — это фоновый процесс, который ускоряет выполнение сборок, избегая постоянной перезагрузки JVM.\
_Как работает Gradle Daemon?_
- Запускается при первой сборке и остаётся в памяти.\
- Кэширует данные (классы, скрипты, зависимости) между запусками.\
- Используется для последующих сборок, уменьшая время старта.\
- Без демона каждый вызов gradle build требует: Загрузки JVM, Парсинга скриптов, Инициализации зависимостей.\
- С демоном эти шаги выполняются один раз, что экономит 20-50% времени.\

## **Как кэширование зависимостей работает в Gradle?**\
_Где хранятся кэшированные зависимости?_\
- Локальный кэш Gradle (~/.gradle/caches/)
  > modules-2/ – Основное хранилище артефактов (JAR, POM, AAR и др.) (Файлы организованы по хешу (например, junit/junit/4.13.2/a478c.../junit-4.13.2.jar).)
  > metadata-2.xx/ – Кэш метаданных (информация о версиях, транзитивных зависимостях).
- Кэш проекта (~/.gradle/caches/modules-2/files-2.1/)
  > Хранит зависимости, специфичные для текущего проекта.\
_Как Gradle решает, использовать кэш или скачивать заново?_\
Gradle проверяет:\
- Наличие файла в локальном кэше (по хешу).\
- Актуальность версии (сравнивает с maven-metadata.xml в репозитории).\
- Изменение build.gradle (если поменялись зависимости, кэш пересчитывается).\
- Если артефакт есть в кэше и актуален – Gradle берёт его оттуда, иначе скачивает.\
_Типы кэширования_\
- Кэш зависимостей (Dependency Cache)\
> Что кэшируется: JAR, POM, исходники (-sources.jar).\
> Где: ~/.gradle/caches/modules-2/.\
> Как обновляется: При изменении версии в build.gradle или При явном вызове --refresh-dependencies.\
- Кэш задач (Task Output Cache)\
> Что кэшируется: Результаты задач (например, скомпилированные классы).\
> Где: ~/.gradle/caches/build-cache-1/.\
> Когда используется: Если задача и её входные данные не изменились, Gradle берёт результат из кэша.\
- Конфигурационный кэш (Configuration Cache) (экспериментальный)\
> Что кэшируется: Граф задач и конфигурация сборки.\
> Эффект: Ускоряет запуск Gradle (не нужно пересчитывать build.gradle каждый раз).\

## **Что такое build.gradle и settings.gradle?**

> build.gradle — настраивает сборку модуля (зависимости, плагины, задачи).\
> settings.gradle — управляет структурой проекта (модули, имя, общие репозитории).\

_build.gradle_\
Главный файл сборки, где настраиваются:\
 - Плагины (например, java, android, spring-boot).\
 - Зависимости (библиотеки, которые использует проект).\
 - Задачи (tasks) (действия, выполняемые при сборке).\
 - Репозитории (откуда скачивать зависимости).\
```
// 1. Подключение плагинов  
plugins {  
    id("java") // Плагин для Java-проектов  
    id("org.springframework.boot") version "3.1.0" // Spring Boot  
}  

// 2. Настройка репозиториев (откуда брать зависимости)  
repositories {  
    mavenCentral() // Основной репозиторий Maven  
    google()      // Для Android-библиотек  
}  

// 3. Зависимости проекта  
dependencies {  
    implementation("org.springframework:spring-core:6.0.0") // Основная библиотека  
    testImplementation("junit:junit:4.13.2") // Библиотека для тестов  
}  

// 4. Кастомные задачи  
tasks.register("hello") {  
    doLast {  
        println("Привет, Gradle!")  
    }  
}  
```
_settings.gradle_\
Определяет структуру проекта, особенно важен для:\
 - Многомодульных проектов (указывает, какие модули включать).\
 - Имени корневого проекта.\
 - Настройки сборки для всех модулей.\
```
// 1. Имя корневого проекта  
rootProject.name = "my-awesome-app"  

// 2. Подключение модулей  
include("app", "core", "data")  

// 3. Настройка репозиториев для всех модулей  
dependencyResolutionManagement {  
    repositories {  
        mavenCentral()  
    }  
} 
```
## **Как работать с Gradle Wrapper? Зачем он нужен?**

## **Как управлять зависимостями (implementation vs api, compileOnly, runtimeOnly)?**

## **Что такое конфигурации (configurations) в Gradle?**


  

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
<details>
  <summary>Git</summary>
## Git
*Что такое merge и rebase? Какая разница?*
>  Merge (слияние)
```
Как работает: Создает новый коммит, который объединяет изменения из двух веток. Этот коммит имеет двух родителей (от каждой ветки).
История коммитов: История остается неизменной, добавляется только новый коммит слияния. Это сохраняет полную историю разработки, включая все ветки.
```
> Rebase (перебазирование)
```
Как работает: Перемещает коммиты из одной ветки и применяет их поверх другой ветки, как если бы они были сделаны последовательно. Это создает линейную историю.
История коммитов: История изменяется, коммиты переписываются, чтобы выглядеть так, как будто они были сделаны поверх текущей ветки. Это делает историю более чистой и линейной.
```
 </details>
 
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
<details>
  <summary>Тесты</summary>
## Тесты
• Как писать unit-тесты для ViewModel? 
• Что такое Mockito и как его использовать? 
• Как тестировать Coroutines? 
• Как писать UI-тесты с помощью Espresso? 
• Как тестировать Compose-компоненты? 
• Что такое JUnit и как его использовать? 
   </details>
   
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


Раскидать
• Как управлять памятью и предотвращать утечки в Android? 
• Что такое WorkManager и когда его использовать? 
• Как использовать WorkManager для фоновых задач? 
• Что такое JobScheduler и как его использовать? 
• Как работать с NotificationManager? 
• Как использовать BiometricPrompt для биометрической аутентификации? 
• Как работать с CameraX? 
• Как использовать Location Services в Android? 
• Что такое App Bundles и зачем они нужны? 
• Как работает Dynamic Delivery? 
• Как использовать Firebase в Android-приложениях? 

